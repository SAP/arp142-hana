#!/bin/bash
umask 022

#------------------------------------------------------------------
# SAP HANA OS checks
#------------------------------------------------------------------
# (C) Copyright SAP 2017-2018
# Author: DBS - CoE EMEA HANA Platform & Technical Infrastructure
#
# Script name: "saphana-logger"
#
# Logging Functions
#------------------------------------------------------------------

# return if saphana-logger already loaded
[[ -n "${HANA_LOGGER_PROGVERSION:-}" ]] && return 0

HANA_LOGGER_PROGVERSION='0.5dev'
#HANA_LOGGER_PROGDATE='2018-MAR-07'

#exec 3>&2 # logging stream (file descriptor 3) defaults to STDERR

# notify/silent=0 (always), error=1, warn=2, info=3, CHK_verbose=4, debug=5, trace=6
logNotify() {		logger 0 '[N]'	"$1"; } # Always prints
logError() {		logger 1 '[E]'	"$1"; }
logWarn() {			logger 2 '[W]'	"$1"; }
logInfo() {			logger 3 '[I]'	"$1"; }
logDebug() {		logger 5 '[D]'	"$1"; }
logTrace() {		logger 6 '[T]'	"$1"; }

logger() {

    local loglevel="$1"
    shift 1

    if [[ ${LOG_VERBOSE_LVL} -ge ${loglevel} ]]; then

        local logleveltag="$1"
        shift 1

        local -r  datestring=$(date +'%H:%M:%S.%3N')
        local -ir prefix_length=$((13+11))	#len("00:04:32.001")+1 && len("[C] <ERROR>")
        local -ir content_width=$((COLUMNS-prefix_length-1))

        # Expand escaped characters, wrap at COLUMNS chars, indent wrapped lines
        # use %b instead of %s for colors
        #printf "%-24b %s\n" "${datestring} ${logleveltag}" "$*" | fold -w ${COLUMNS} | sed '2~1s/^/                        /' #>&3
        if [[ -t 1 ]]; then #FD1 = stdout
            local line
            printf '%s\n' "$*" | fold -w ${content_width} | { read -r line ; printf "%-${prefix_length}b %s\\n" "${datestring} ${logleveltag}" "${line}" ; while read -r line ; do printf "%-${prefix_length}s %s\\n" " " "${line}" ; done }
        else
            printf "%-${prefix_length}b %s\\n" "${datestring} ${logleveltag}" "$*"
        fi
    fi
}


#ToDo: remove/revise use_colored_output stuff
use_colored_output() {
    return ${LOG_COLOR_CHECK}
}

logCheckError() {

    if use_colored_output; then
        logger 1 "[C] ${fmt_error}<ERROR>${fmt_reset}"	"$@"
    else
        logger 1 '[C] <ERROR>' "$@"
    fi
}

logCheckWarning() {

    if use_colored_output; then
        #we need the trailing space, because color formatting prevents padding
        logger 2 "[C] ${fmt_warn}${fmt_blbackgr}<WARN>${fmt_reset} "	"$@"
    else
        logger 2 '[C] <WARN>' "$@"
    fi
}

logCheckOk() {

    if use_colored_output; then
        logger 3 "[C] ${fmt_ok}<OK>${fmt_reset}   "	"$@"
    else
        logger 3 '[C] <OK>' "$@"
    fi
}

logCheckInfo() {

    if use_colored_output; then
        logger 4 "[C] ${fmt_info}<INFO>${fmt_reset} " "$@"
    else
        logger 4 '[C] <INFO>' "$@"
    fi
}

logCheckSkipped() {

    #echo "Caller Check #: <${FUNCNAME[1]:6:3}>"

    if use_colored_output; then
        logger 4 "[C] ${fmt_skip}<SKIP>${fmt_reset} "	"$@"
    else
        logger 4 '[C] <SKIP>' "$@"
    fi
}


#============================================================
# LIB MAIN - initialization
#============================================================
_lib_logger_main() {

    COLUMNS=80 # required before 1st logger usage

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    # ToDo: -t 1 stdout?
    #  if [[ -t 1 && -n "$TERM" && "$TERM" != "dumb" ]]; then
    if [[ -n "$TERM" && "$TERM" != "dumb" ]]; then
        COLUMNS=$(tput cols)
    fi

    fmt_ok='\033[0;32m' # 1=Bold; 32m=Green
    fmt_error='\033[1;31m' # Red
    fmt_warn='\033[0;33m' # Yellow
    fmt_info='\033[1;37m' # Bold gray
    fmt_skip='\033[0;37m' # Light gray
    fmt_blbackgr='\033[40m'    # Black background
    fmt_reset='\033[0m'   #'\033[m\017'
}

# Variables to be used by other
declare -i LOG_VERBOSE_LVL=3 #notify/silent=0 (always), error=1, warn=2, info=3, CHK_verbose=4, debug=5, trace=6
declare -i LOG_COLOR_CHECK=1 #1=off, 0=on

# ToDo: declare -ix ?? - logging should also work for pipes (grep or less)
declare -i COLUMNS
_lib_logger_main