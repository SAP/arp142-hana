#!/bin/bash
umask 022

#------------------------------------------------------------------
# SAP HANA OS checks
#------------------------------------------------------------------
# (C) Copyright SAP 2017-2018
# Author: DBS - CoE EMEA HANA Platform & Technical Infrastructure
#
# Script name: "saphana-helper-funcs"
#
# Library Functions
#------------------------------------------------------------------

# Everything that is for global access after sourcing this script
# has got the prefix LIB_.

# return if saphana-helper-funcs already loaded
[[ -n "${HANA_HELPER_PROGVERSION:-}" ]] && return 0

HANA_HELPER_PROGVERSION='0.5dev'
#HANA_HELPER_PROGDATE='2018-MAR-07'

##################################################
# Global functions - to be used in other scripts
##################################################
function LIB_FUNC_CHECK_CHECK_SECURITY {

    local fullpath=$1

    local -i fileownerid
    fileownerid=$(stat -c %u "${fullpath}")
    if [[ "${fileownerid}" -ne 0 ]]; then
        printf 'Check %s is not owned by root.\n'	"${fullpath}"
        return 1
    fi

    local fileperm
    fileperm=$(stat -c %A "${fullpath}")
    if [[ "${fileperm}" != ?r???-??-? ]]; then
        printf 'Check %s is world writable.\n'	"${fullpath}"
        return 1
    fi
}

# Returns 1 on Virtualization, 0 on Bare-Metal
function LIB_FUNC_IS_BARE_METAL {

    local -i _retval=1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    [[ ${lib_platf_virtualized} -ne 0 ]] &&	_retval=0

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

# Returns 0 on Intel, 1 on other
function LIB_FUNC_IS_INTEL {

    local -i _retval=1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    [[ "${LIB_PLATF_CPU_VENDOR:-}" == 'GenuineIntel' ]] && _retval=0

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

# Returns 0 on AMD, 1 on other
function LIB_FUNC_IS_AMD {

    local -i _retval=1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    [[ "${LIB_PLATF_CPU_VENDOR:-}" == 'AuthenticAMD' ]] && _retval=0

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

# Returns 0 on x86_64, 1 on other
function LIB_FUNC_IS_X64 {

    local -i _retval=1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    [[ "${LIB_PLATF_ARCHITECTURE:-}" == 'x86_64' ]] && _retval=0

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

# Returns 0 on Power, 1 on other
function LIB_FUNC_IS_IBMPOWER {

    local -i _retval=1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    if [[ "${LIB_PLATF_ARCHITECTURE}" == 'ppc64le' ]] || [[ "${LIB_PLATF_ARCHITECTURE}" == 'ppc64' ]]; then
        _retval=0
    fi

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

# Compares two version strings
# Two version strings as parameters.
# Echos & returns 0 if equal, 1 if first is higher, 2 if second is higher
# - no external utilities - factor 10x faster than original (tr,grep are quite expansive)
function LIB_FUNC_COMPARE_VERSIONS {

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    local -i _retval=0
    local version1
    local version2
    version1=$(LIB_FUNC_TRIM "$1")
    version2=$(LIB_FUNC_TRIM "$2")

    #${1//\-/\.} - Variable Substitution (faster then tr,sed or grep) - replace - by .
    #required for 2.11.3-17.95.2 --> 2.11.3.17.95.2
    version1=${version1//\-/\.}
    version2=${version2//\-/\.}

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # compare <${version1}> to <${version2}>"

    if [[ "${version1}" == "${version2}" ]]; then
        _retval=0
    else

        #to_array, split by .
        local IFS=.
        local -a ver1
        local -a ver2
        read -r -a ver1 <<< "${version1}"
        read -r -a ver2 <<< "${version2}"

        local -i i
        # fill empty fields in ver1 with zeros
        for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
            ver1[i]=0
        done

        for ((i=0; i<${#ver1[@]}; i++)); do
            if [[ -z ${ver2[i]:-} ]]; then
                # fill empty fields in ver2 with zeros
                ver2[i]=0
            fi
            if ((10#${ver1[i]} > 10#${ver2[i]})); then
                _retval=1
                break
            fi
            if ((10#${ver1[i]} < 10#${ver2[i]})); then
                _retval=2
                break
            fi
        done

    fi

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

function LIB_COMPARE_TOOBIG_NUMBERS {
# Two large numbers as string parameters.
# returns 0 if equal, 1 if first is higher, 2 if second is higher

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    local -i _retval=-1
    local number1
    local number2
    number1="$1"
    number2="$2"

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # compare <${number1}> to <${number2}>"

    if [[ "${number1}" == "${number2}" ]]; then
        _retval=0

    elif [[ ${#number1} -gt ${#number2} ]]; then
        _retval=1

    elif [[ ${#number1} -lt ${#number2} ]]; then
        _retval=2

    elif [[ ${#number1} -le 18  ]]; then

        _retval=$(( number1 > number2 ? 1 : 2 ))

    else

        #too large to be handled as integers; split and compare high/low part
        local -i number1part
        local -i number2part

        #higher part
        number1part=${number1:0:(( ${#number1} - 18 ))}
        number2part=${number2:0:(( ${#number2} - 18 ))}

        if [[ ${number1part} -gt ${number2part} ]]; then
            _retval=1

        elif [[ ${number1part} -lt ${number2part} ]]; then
            _retval=2

        else

            #lower part
            number1part=${number1:(-18)}
            number2part=${number2:(-18)}
            _retval=$(( number1part > number2part ? 1 : 2 ))

        fi

    fi

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
    return ${_retval}
}

function LIB_FUNC_TRIM_LEFT {
    local var="$*"
    # remove leading whitespace characters
    printf '%s' "${var#"${var%%[![:space:]]*}"}"
}

function LIB_FUNC_TRIM_RIGHT {
    local var="$*"
    # remove trailing whitespace characters
    printf '%s' "${var%"${var##*[![:space:]]}"}"
}

function LIB_FUNC_TRIM {
    local var="$*"
    var=$(LIB_FUNC_TRIM_LEFT "${var}")
    var=$(LIB_FUNC_TRIM_RIGHT "${var}")
    printf '%s' "$var"
}

function LIB_FUNC_NORMALIZE_KERNEL {

    local kernelversion="$1"
    shift 1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    kernelversion=${kernelversion/PTF-default*/1}	#3.0.101-0.47.71.7930.0.PTF-default
    kernelversion=${kernelversion/default*/1}		#3.0.101-0.47.71-default
    kernelversion=${kernelversion/bigsmp*/1}			#3.0.101-0.47-bigsmp
    kernelversion=${kernelversion/bigmem*/1}			#3.0.101-88-bigmem
    kernelversion=${kernelversion/ppc64*/1}			#3.0.101-71-ppc64
    kernelversion=${kernelversion/.el[[:digit:]]*/}		# Remove trailing ".el6.x86_64" or ".el7.ppc64le"

    LIB_FUNC_NORMALIZE_KERNEL_return="${kernelversion}"	#variable is available to caller
}

function LIB_FUNC_NORMALIZE_RPM {

    local rpmversion="$1"
    shift 1

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    rpmversion=${rpmversion/.el[[:digit:]]*_[[:digit:]]*./.0.}		# 2.17-157.el7_3.5	-> 2.17-157.0.5
    rpmversion=${rpmversion/.el[[:digit:]]*/.0}						# 219-30.el7		-> 219-30.0

    LIB_FUNC_NORMALIZE_RPM_RETURN="${rpmversion}"	#variable is available to caller
}


function LIB_FUNC_STRINGCONTAIN {

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    #$1=string $2=substring
    #case "$1" in *"$2"* ) return 0;;esac
    #return 1
    [[ -z "${1##*$2*}" ]] && [[ -z "$2" || -n "$1" ]];
}

##########################################################
# Non-global functions - not to be used in other scripts
##########################################################

function __get_platform_cpu_details {

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    # get System details
    local -a platform

    local -r IFS=$'\n';
    platform=( "$(lscpu)" )

    local line
    for line in ${platform[*]:-}; do

        logTrace "<${FUNCNAME[0]}> # ${line}>"

        case ${line} in

        "Architecture:"*)
                            if [[ ! -n ${LIB_PLATF_ARCHITECTURE:-} ]]; then
                                LIB_PLATF_ARCHITECTURE=$(LIB_FUNC_TRIM_LEFT "${line/Architecture:}")
                                readonly LIB_PLATF_ARCHITECTURE
                            fi
        ;;
        "Byte Order:"*)
                            LIB_PLATF_BYTEORDER=$(LIB_FUNC_TRIM_LEFT "${line/Byte Order:}")
                            readonly LIB_PLATF_BYTEORDER
                            #break
        ;;

        # "Thread(s) per core:"*)

        # ;;

        # "Core(s) per socket:"*)

        # ;;

        # "NUMA node(s):"*)

        # ;;

        "Vendor ID:"*)		#GenuineIntel; AuthenticAMD
                            if [[ ! -n ${LIB_PLATF_CPU_VENDOR:-} ]]; then
                                LIB_PLATF_CPU_VENDOR=$(LIB_FUNC_TRIM_LEFT "${line/Vendor ID:}")
                                readonly LIB_PLATF_CPU_VENDOR
                            fi
        ;;

        "Model:"*)			#on Power <Model: IBM,9119-MHE> ; on Intel <Model: 63>
                            if LIB_FUNC_IS_IBMPOWER ; then
                                LIB_PLATF_NAME=$(LIB_FUNC_TRIM_LEFT "${line/Model:}")
                                readonly LIB_PLATF_NAME
                                LIB_PLATF_VENDOR='IBM'
                                readonly LIB_PLATF_VENDOR

                            elif LIB_FUNC_IS_INTEL || LIB_FUNC_IS_AMD ; then
                                LIB_PLATF_CPU_MODELID=$(LIB_FUNC_TRIM_LEFT "${line/Model:}")
                                readonly LIB_PLATF_CPU_MODELID
                            fi
        ;;

        "Model name:"*)		#on x64 only
                            #<Intel(R) Xeon(R) CPU E7-8880 v3 @ 2.30GHz>; AMD Opteron 23xx (Gen 3 Class Opteron)
                            if [[ ! -n ${LIB_PLATF_CPU:-} ]]; then
                                LIB_PLATF_CPU=$(LIB_FUNC_TRIM_LEFT "${line/Model name:}")
                                readonly LIB_PLATF_CPU
                            fi
        ;;

        # Virtualization information provieded by lscpu version >=2.25 and only if virtualized
        # x64:		( VMware - full ) ; ( Xen - none ) ;
        # Power:	( pHyp - para ) ; ( pHyp - none ) ; ( KVM - para ) ; ( none - none ) = PowerNV = bare-metal

        "Hypervisor vendor:"*)
                            if [[ ! -n ${LIB_PLATF_VIRT_VENDOR:-} ]]; then
                                LIB_PLATF_VIRT_VENDOR=$(LIB_FUNC_TRIM_LEFT "${line/Hypervisor vendor:}")
                                readonly LIB_PLATF_VIRT_VENDOR
                            fi
        ;;

        "Virtualization type:"*)
                            if [[ ! -n ${LIB_PLATF_VIRT_TYPE:-} ]]; then
                                LIB_PLATF_VIRT_TYPE=$(LIB_FUNC_TRIM_LEFT "${line/Virtualization type:}")
                                readonly LIB_PLATF_VIRT_TYPE
                            fi
                            break
        ;;

        esac

    done

    if [[ ! -n ${LIB_PLATF_CPU:-} ]]; then

        if LIB_FUNC_IS_X64 ; then
            LIB_PLATF_CPU=$(grep  'model name' /proc/cpuinfo | sort -u)
            LIB_PLATF_CPU=$(LIB_FUNC_TRIM_LEFT "${LIB_PLATF_CPU/model name[[:blank:]]:}")

        elif LIB_FUNC_IS_IBMPOWER ; then
            LIB_PLATF_CPU=$(grep  'cpu' /proc/cpuinfo | sort -u)
            LIB_PLATF_CPU=$(LIB_FUNC_TRIM_LEFT "${LIB_PLATF_CPU/cpu[[:space:]]*:}")
        fi

        readonly LIB_PLATF_CPU
    fi
}

function __get_platform_mem_details {

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    local collectedby

    #dmesg - kernel boot message
    if [[ ! -n ${LIB_PLATF_RAM_MiB_PHYS:-} && -x "$(command -v dmesg)" ]]; then

        local boot_mem_line
        boot_mem_line=$(dmesg | grep "Memory:.*available")
        LIB_PLATF_RAM_MiB_PHYS=$(awk '/Memory:.*available/ {match($0, /\/([0-9]+?)(K|k)/); printf "%.0f", substr($0,RSTART+1,RLENGTH-2) / 1024 }' <<< "${boot_mem_line}" )

        #since 3.11 - reports the total number of physical pages in the system; before max_pfn --> need to substract absent memory
        local -i boot_mem_absent_mb
        boot_mem_absent_mb=$(awk '/Memory:.*available/ {match($0, /([0-9]+?)k absent/); printf "%.0f", substr($0,RSTART,RLENGTH-2) / 1024}' <<< "${boot_mem_line}" )
        [[ ${boot_mem_absent_mb} -ne 0 ]] && LIB_PLATF_RAM_MiB_PHYS=$(( LIB_PLATF_RAM_MiB_PHYS - boot_mem_absent_mb ))

        collectedby='dmesg'

    fi

    #MemTotal in /proc/meminfo - usable memory
    LIB_PLATF_RAM_MiB_AVAILABLE=$(awk '/^MemTotal:/ {match($0, /[0-9]+/); printf "%.0f", substr($0,RSTART,RLENGTH)/1024 }' /proc/meminfo)

    if [[ ! -n ${LIB_PLATF_RAM_MiB_PHYS:-} || ${LIB_PLATF_RAM_MiB_PHYS} -eq 0 ]]; then

        LIB_PLATF_RAM_MiB_PHYS=${LIB_PLATF_RAM_MiB_AVAILABLE:-}
        collectedby='meminfo'

    fi

    readonly LIB_PLATF_RAM_MiB_PHYS
    readonly LIB_PLATF_RAM_MiB_AVAILABLE

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # LIB_PLATF_RAM_MiB_PHYS (${collectedby:-}): ${LIB_PLATF_RAM_MiB_PHYS:-}; LIB_PLATF_RAM_MiB_AVAILABLE ${LIB_PLATF_RAM_MiB_AVAILABLE:-}"
}

#============================================================
# LIB MAIN - initialization
#============================================================
function _lib_helper_main {

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

    __get_platform_cpu_details

    # ToDo:	Power platform does not provide 'dmidecode or /sys/devices/virtual/dmi/id'
    if [[ -e '/sys/devices/virtual/dmi/id' ]]; then

        # Vendor - IBM, Lenovo, ...
        if [[ ! -n ${LIB_PLATF_VENDOR:-} ]]; then
            LIB_PLATF_VENDOR="$(</sys/devices/virtual/dmi/id/sys_vendor)"
            readonly LIB_PLATF_VENDOR
        fi

        # Platform - "x3950 X6 -[6241ZB5]-", "ProLiant DL785 G6", "VMware Virtual Platform", "RHEV Hypervisor"
        if [[ ! -n ${LIB_PLATF_NAME:-} ]]; then
            LIB_PLATF_NAME="$(</sys/devices/virtual/dmi/id/product_name)"
            readonly LIB_PLATF_NAME
        fi

    fi

    __get_platform_mem_details

    # ToDo:	verify for AMD processors
    lib_platf_virtualized=$(grep -q '^flags.*hypervisor' /proc/cpuinfo;echo $?)
    readonly lib_platf_virtualized

}

##########################################################
#GLOBAL -x --> exported
declare		LIB_PLATF_VENDOR
declare		LIB_PLATF_NAME
declare 	LIB_PLATF_CPU_VENDOR
declare 	LIB_PLATF_CPU
declare -i	LIB_PLATF_CPU_MODELID
declare -i	LIB_PLATF_RAM_MiB_PHYS
declare -i	LIB_PLATF_RAM_MiB_AVAILABLE

declare 	LIB_PLATF_ARCHITECTURE
declare 	LIB_PLATF_BYTEORDER

declare		LIB_PLATF_VIRT_VENDOR
declare		LIB_PLATF_VIRT_TYPE

#LIB local
declare -i lib_platf_virtualized


#Import libraries
source "$( cd "${BASH_SOURCE[0]%/*}" && pwd )/saphana-logger" || { echo 'unable to load saphana-logger library' >&2; exit 1; }
source "$( cd "${BASH_SOURCE[0]%/*}" && pwd )/lib_linux_release" || { echo 'unable to load lib_linux_release library' >&2; exit 1; }

_lib_helper_main
