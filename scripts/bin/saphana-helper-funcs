#!/bin/bash
umask 022

#------------------------------------------------------------------
# SAP HANA OS checks
#------------------------------------------------------------------
# (C) Copyright SAP 2017
# Author: DBS - CoE EMEA HANA Platform & Technical Infrastructure 
#
# Script name: "saphana-helper-funcs"
#
# Library Functions
#------------------------------------------------------------------

# Everything that is for global access after sourcing this script
# has got the prefix LIB_.

# return if saphana-helper-funcs already loaded
[[ -n "${HANA_HELPER_VERSION:-}" ]] && return 0

HANA_HELPER_VERSION='0.3-dev'
#HANA_HELPER_DATE='2017-SEP-27'

##################################################
# Global functions - to be used in other scripts
##################################################
lib_func_check_check_security() {
    
	local fullpath=$1

	local -i fileownerid
	fileownerid=$(stat -c %u "${fullpath}")
	if [[ "${fileownerid}" -ne 0 ]]; then
		printf 'Check %s is not owned by root.\n'	"${fullpath}"
		return 1
	fi

	local fileperm
	fileperm=$(stat -c %A "${fullpath}")
	if [[ "${fileperm}" != ?r???-??-? ]]; then
		printf 'Check %s is world writable.\n'	"${fullpath}"
		return 1
	fi
}

lib_func_get_linux_distrib() {

	#a local variable declared in a function is also visible to functions called by the parent function.
	local -r osfile='/etc/os-release'
	local -r susefile='/etc/SuSE-release'
	local -r redhatfile='/etc/redhat-release'
	local -r oraclefile='/etc/oracle-release'

	local _os_name
	local _os_version

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	if [ -f ${osfile} ] ; then
		#newer releases contain this file
		__linux_distrib_os_release "${osfile}"

	elif [ -f ${susefile} ] ; then
		__linux_distrib_suse_release "${susefile}"

	elif [ -f ${oraclefile} ] ; then
		#oracle is based on RedHat - redhatfile also exist, but check oracle first
		__linux_distrib_oracle_release "${oraclefile}"

	elif [ -f ${redhatfile} ] ; then
		__linux_distrib_redhat_release "${redhatfile}"

	else
		_os_name='Linux UNKNOWN'
	fi

	OS_NAME="${_os_name}"
	OS_VERSION="${_os_version}"
	OS_LEVEL=$(uname -r)

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # ${OS_NAME} ; ${OS_VERSION} ; ${OS_LEVEL}"

}

# Returns 0 on SLES, 1 on other
lib_func_is_sles() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	if [[ "${OS_NAME}" == 'Linux SLES' ]]; then
		_retval=0
	fi

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Returns 0 on RHEL, 1 on other
lib_func_is_rhel() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	if [[ "${OS_NAME}" == 'Linux RHEL' ]]; then
		_retval=0
	fi

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Returns 1 on Virtualization, 0 on Bare-Metal
lib_func_is_bare_metal() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	[[ ${lib_platf_virtualized} -ne 0 ]] &&	_retval=0

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Returns 0 on Intel, 1 on other
lib_func_is_intel() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	[[ "${LIB_PLATF_CPU_VENDOR:-}" == 'GenuineIntel' ]] && _retval=0

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Returns 0 on AMD, 1 on other
lib_func_is_amd() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	[[ "${LIB_PLATF_CPU_VENDOR:-}" == 'AuthenticAMD' ]] && _retval=0

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Returns 0 on x86_64, 1 on other
lib_func_is_x64() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	[[ "${LIB_PLATF_ARCHITECTURE:-}" == 'x86_64' ]] && _retval=0

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Returns 0 on Power, 1 on other
lib_func_is_ibmpower() {

	local -i _retval=1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	if [[ "${LIB_PLATF_ARCHITECTURE}" == 'ppc64le' ]] || [[ "${LIB_PLATF_ARCHITECTURE}" == 'ppc64' ]]; then
		_retval=0
	fi

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}

# Compares two version strings
# Two version strings as parameters.
# Echos & returns 0 if equal, 1 if first is higher, 2 if second is higher
# - no external utilities - factor 10x faster than original (tr,grep are quite expansive)
lib_func_compare_versions() {

    logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	local -i _retval=0
	local version1
	local version2
    version1=$(lib_func_trim "$1")
	version2=$(lib_func_trim "$2")

    #${1//\-/\.} - Variable Substitution (faster then tr,sed or grep) - replace - by .
	#required for 2.11.3-17.95.2 --> 2.11.3.17.95.2
    version1=${version1//\-/\.}
    version2=${version2//\-/\.}

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # compare <${version1}> to <${version2}>"

    if [[ "${version1}" == "${version2}" ]]; then
        _retval=0
    else

		#to_array, split by .
        local IFS=.
        local -a ver1
        local -a ver2
		read -r -a ver1 <<< "${version1}"
		read -r -a ver2 <<< "${version2}"

        local -i i
        # fill empty fields in ver1 with zeros
        for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
        do
            ver1[i]=0
        done

        for ((i=0; i<${#ver1[@]}; i++))
        do
            if [[ -z ${ver2[i]:-} ]]
            then
                # fill empty fields in ver2 with zeros
                ver2[i]=0
            fi
            if ((10#${ver1[i]} > 10#${ver2[i]}))
            then
                _retval=1
                break
            fi
            if ((10#${ver1[i]} < 10#${ver2[i]}))
            then
                _retval=2
                break
            fi
        done

    fi

    logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # RC=${_retval}"
	return ${_retval}
}


lib_func_trim_left() {
    local var="$*"
    # remove leading whitespace characters
    printf '%s' "${var#"${var%%[![:space:]]*}"}"
}

lib_func_trim_right() {
    local var="$*"
    # remove trailing whitespace characters
    printf '%s' "${var%"${var##*[![:space:]]}"}"
}

lib_func_trim() {
    local var="$*"
    var=$(lib_func_trim_left "${var}")
    var=$(lib_func_trim_right "${var}")
    printf '%s' "$var"
}

lib_func_normalize_kernel() {

	local kernelversion="$1"
	shift 1

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	kernelversion=${kernelversion/PTF-default*/1}	#3.0.101-0.47.71.7930.0.PTF-default
	kernelversion=${kernelversion/default*/1}		#3.0.101-0.47.71-default
	kernelversion=${kernelversion/bigsmp*/1}			#3.0.101-0.47-bigsmp
	kernelversion=${kernelversion/bigmem*/1}			#3.0.101-88-bigmem
	kernelversion=${kernelversion/ppc64*/1}			#3.0.101-71-ppc64
	kernelversion=${kernelversion/.el[[:digit:]]*/}		# Remove trailing ".el6.x86_64"

	lib_func_normalize_kernel_return="${kernelversion}"	#variable is available to caller
}
##########################################################
# Non-global functions - not to be used in other scripts
##########################################################

__linux_distrib_os_release() {

	local _os_release_file="$1"
	shift 1

	local _ostmp
	local _osname
	local _osvers

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	while read -r line; do

		logTrace "<${FUNCNAME[0]}> # ${_os_release_file}:${line}"

		#NAME=""
		_ostmp=$(awk '/^NAME=/ {match($0, /".*"/); print substr($0,RSTART+1,RLENGTH-2)}' <<< "${line}")
		_osname=${_osname:=$_ostmp}

		#match 12.1 | 12.0.1 | 7.0
		_ostmp=$(awk '/^VERSION_ID=/ {match($0, /([0-9]+)(\.([0-9]+))+/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_osvers=${_osvers:=$_ostmp}

	done < "${_os_release_file}"

	_os_version="${_osvers}"

	case ${_osname} in
		"SLES"*)
				_os_name='Linux SLES'
				;;

		"Red Hat Enterprise Linux Server")
				_os_name='Linux RHEL'
				;;

		"Oracle Linux Server")
				_os_name='Linux OLS'
				;;

		*)
			_os_name='Linux UNKNOWN'
			;;
	esac
}

__linux_distrib_suse_release() {

	local _suse_release_file="$1"
	shift 1

	local _ostmp
	local _osname
	local _osvers
	local _susepatchl

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	while read -r line; do

		logTrace "<${FUNCNAME[0]}> # ${_suse_release_file}:${line}"

		#Enterprise?
		_ostmp=$(awk '/^SUSE Linux Enterprise/ {match($0, /([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_osname=${_osname:=$_ostmp}

		#11 - version
		_ostmp=$(awk '/^VERSION = / {match($0, /([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_osvers=${_osvers:=$_ostmp}

		#2	- patchlevel
		_ostmp=$(awk '/^PATCHLEVEL = / {match($0, /([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_susepatchl=${_susepatchl:=$_ostmp}

	done < "${_suse_release_file}"

	_os_version="${_osvers}.${_susepatchl}"

	if [ -n "${_osname}" ] ; then
		_os_name='Linux SLES'
	else
		_os_name='Linux Suse UNKNOWN'
	fi
}

__linux_distrib_oracle_release() {

	local _oracle_release_file="$1"
	shift 1

	local _oltmp
	local _olname
	local _olversion

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	#oracle is based on RedHat - redhatfile also exist, but check oracle first
	while read -r line; do

		logTrace "<${FUNCNAME[0]}> # ${_oracle_release_file}:${line}"

		#Server within string - match any number
		_oltmp=$(awk '/^Oracle Linux Server/ {match($0, /([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_olname=${_olname:=$_oltmp}

		#match 6.4
		_oltmp=$(awk '/^Oracle Linux/ {match($0, /([0-9]+)\.([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_olversion=${_olversion:=$_oltmp}

	done < "${_oracle_release_file}"

	_os_version=${_olversion}

	if [ -n "${_olname}" ] ; then
		_os_name='Linux OLS'
	else
		_os_name='Linux Oracle UNKNOWN'
	fi
}

__linux_distrib_redhat_release() {

	local _redhat_release_file="$1"
	shift 1

	local _rhtmp
	local _rhname
	local _rhversion

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	while read -r line; do

		logTrace "<${FUNCNAME[0]}> # ${_redhat_release_file}:${line}"

		#Enterprise within string - match any number
		_rhtmp=$(awk '/^Red Hat Enterprise Linux/ {match($0, /([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_rhname=${_rhname:=$_rhtmp}

		#match 6.4
		_rhtmp=$(awk '/^Red Hat/ {match($0, /([0-9]+)\.([0-9]+)/); print substr($0,RSTART,RLENGTH) }' <<< "${line}")
		_rhversion=${_rhversion:=$_rhtmp}

	done < "${_redhat_release_file}"

	_os_version=${_rhversion}

	if [ -n "${_rhname}" ] ; then
		_os_name='Linux RHEL'
	else
		_os_name='Linux Redhat UNKNOWN'
	fi

}

__get_platform_cpu_details() {

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	# get System details
	local -r IFS=$'\n'
	local -a platform

	platform=($(lscpu))

	for ((i=0; i < ${#platform[@]}; ++i)); do

		logTrace "<${FUNCNAME[0]}> # ${platform[$i]}>"

		case ${platform[$i]} in

		"Architecture:"*)
							if [[ ! -n ${LIB_PLATF_ARCHITECTURE:-} ]]; then
								LIB_PLATF_ARCHITECTURE=$(lib_func_trim_left "${platform[$i]/Architecture:}")
								readonly LIB_PLATF_ARCHITECTURE
							fi
		;;
		"Byte Order:"*)
							LIB_PLATF_BYTEORDER=$(lib_func_trim_left "${platform[$i]/Byte Order:}")
							readonly LIB_PLATF_BYTEORDER
							#break
		;;

		# "Thread(s) per core:"*)

		# ;;

		# "Core(s) per socket:"*)

		# ;;

		# "NUMA node(s):"*)

		# ;;

		"Vendor ID:"*)		#GenuineIntel; AuthenticAMD
							if [[ ! -n ${LIB_PLATF_CPU_VENDOR:-} ]]; then
		 						LIB_PLATF_CPU_VENDOR=$(lib_func_trim_left "${platform[$i]/Vendor ID:}")
		 						readonly LIB_PLATF_CPU_VENDOR
							fi
		;;

		"Model:"*)			#on Power <Model: IBM,9119-MHE> ; on Intel <Model: 63>
							if lib_func_is_ibmpower ; then
								LIB_PLATF_NAME=$(lib_func_trim_left ${platform[$i]/Model:})
								readonly LIB_PLATF_NAME
								LIB_PLATF_VENDOR='IBM'
								readonly LIB_PLATF_VENDOR
							
							elif lib_func_is_intel || lib_func_is_amd ; then
								LIB_PLATF_CPU_MODELID=$(lib_func_trim_left ${platform[$i]/Model:})
								readonly LIB_PLATF_CPU_MODELID

							fi
		;;

		"Model name:"*)		#on x64 only	
							#<Intel(R) Xeon(R) CPU E7-8880 v3 @ 2.30GHz>; AMD Opteron 23xx (Gen 3 Class Opteron)
							if [[ ! -n ${LIB_PLATF_CPU:-} ]]; then
		 						LIB_PLATF_CPU=$(lib_func_trim_left "${platform[$i]/Model name:}")
		 						readonly LIB_PLATF_CPU
							fi
		;;

		# Virtualization information provieded by lscpu version >=2.25 and only if virtualized
		# x64:		( VMware - full ) ; ( Xen - none ) ; 
		# Power:	( pHyp - para ) ; ( pHyp - none ) ; ( KVM - para ) ; ( none - none ) = PowerNV = bare-metal

		"Hypervisor vendor:"*)
							if [[ ! -n ${LIB_PLATF_VIRT_VENDOR:-} ]]; then
		 						LIB_PLATF_VIRT_VENDOR=$(lib_func_trim_left "${platform[$i]/Hypervisor vendor:}")
		 						readonly LIB_PLATF_VIRT_VENDOR
							fi
		;;

		"Virtualization type:"*)
							if [[ ! -n ${LIB_PLATF_VIRT_TYPE:-} ]]; then
		 						LIB_PLATF_VIRT_TYPE=$(lib_func_trim_left "${platform[$i]/Virtualization type:}")
		 						readonly LIB_PLATF_VIRT_TYPE
							fi
							break
		;;

		esac

	done

}

__get_platform_mem_details() {

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	local collectedby

	#dmesg - kernel boot message
	if [[ ! -n ${LIB_PLATF_RAM_MiB_PHYS:-} && -x "$(command -v dmesg)" ]]; then

		local boot_mem_line=$(dmesg | grep Memory:.*available)
		LIB_PLATF_RAM_MiB_PHYS=$(awk '/Memory:.*available/ {match($0, /\/([0-9]+?)(K|k)/); printf "%.0f", substr($0,RSTART+1,RLENGTH-2) / 1024 }' <<< "${boot_mem_line}" )

		#since 3.11 - reports the total number of physical pages in the system; before max_pfn --> need to substract absent memory
		local -i boot_mem_absent_mb
		boot_mem_absent_mb=$(awk '/Memory:.*available/ {match($0, /([0-9]+?)k absent/); printf "%.0f", substr($0,RSTART,RLENGTH-2) / 1024}' <<< "${boot_mem_line}" )
		[[ ${boot_mem_absent_mb} -ne 0 ]] && LIB_PLATF_RAM_MiB_PHYS=$(( LIB_PLATF_RAM_MiB_PHYS - boot_mem_absent_mb )) 

		collectedby='dmesg'

	fi

	#MemTotal in /proc/meminfo - usable memory
	LIB_PLATF_RAM_MiB_AVAILABLE=$(awk '/^MemTotal:/ {match($0, /[0-9]+/); printf "%.0f", substr($0,RSTART,RLENGTH)/1024 }' /proc/meminfo)
	
	if [[ ! -n ${LIB_PLATF_RAM_MiB_PHYS:-} || ${LIB_PLATF_RAM_MiB_PHYS} -eq 0 ]]; then

		LIB_PLATF_RAM_MiB_PHYS=${LIB_PLATF_RAM_MiB_AVAILABLE:-}
		collectedby='meminfo'

	fi

	readonly LIB_PLATF_RAM_MiB_PHYS
	readonly LIB_PLATF_RAM_MiB_AVAILABLE

	logDebug "<${BASH_SOURCE[0]}:${FUNCNAME[0]}> # LIB_PLATF_RAM_MiB_PHYS (${collectedby:-}): ${LIB_PLATF_RAM_MiB_PHYS:-}; LIB_PLATF_RAM_MiB_AVAILABLE ${LIB_PLATF_RAM_MiB_AVAILABLE:-}"
}

#============================================================
# LIB MAIN - initialization
#============================================================
_lib_helper_main() {

	logTrace "<${BASH_SOURCE[0]}:${FUNCNAME[*]}>"

	lib_func_get_linux_distrib

	__get_platform_cpu_details

	# ToDo:	Power platform does not provide 'dmidecode'
	if [[ -x "$(command -v dmidecode)" ]]; then

		# Vendor - IBM, Lenovo, ...
		if [[ ! -n ${LIB_PLATF_VENDOR:-} ]]; then
			LIB_PLATF_VENDOR=$(dmidecode -s system-manufacturer)
			readonly LIB_PLATF_VENDOR
		fi

		# Platform - "x3950 X6 -[6241ZB5]-", "ProLiant DL785 G6", "VMware Virtual Platform", "RHEV Hypervisor"
		if [[ ! -n ${LIB_PLATF_NAME:-} ]]; then
			LIB_PLATF_NAME=$(dmidecode -s system-product-name)
			readonly LIB_PLATF_NAME
		fi

	fi

	if [[ ! -n ${LIB_PLATF_CPU:-} ]]; then

		if lib_func_is_x64 ; then
			LIB_PLATF_CPU=$(grep  'model name' /proc/cpuinfo | sort -u)
			LIB_PLATF_CPU=$(lib_func_trim_left "${LIB_PLATF_CPU/model name[[:blank:]]:}")

		elif lib_func_is_ibmpower ; then
			LIB_PLATF_CPU=$(grep  'cpu' /proc/cpuinfo | sort -u)
			LIB_PLATF_CPU=$(lib_func_trim_left "${LIB_PLATF_CPU/cpu[[:space:]]*:}")
		fi

		readonly LIB_PLATF_CPU
	fi

	__get_platform_mem_details

	# ToDo:	verify for AMD processors
	lib_platf_virtualized=$(grep -q '^flags.*hypervisor' /proc/cpuinfo;echo $?)
	readonly lib_platf_virtualized

}

##########################################################
#GLOBAL -x --> exported
declare		LIB_PLATF_VENDOR
declare		LIB_PLATF_NAME
declare 	LIB_PLATF_CPU_VENDOR
declare 	LIB_PLATF_CPU
declare 	LIB_PLATF_CPU_MODELID
declare -i	LIB_PLATF_RAM_MiB_PHYS
declare -i	LIB_PLATF_RAM_MiB_AVAILABLE

declare 	LIB_PLATF_ARCHITECTURE
declare 	LIB_PLATF_BYTEORDER

declare		LIB_PLATF_VIRT_VENDOR
declare		LIB_PLATF_VIRT_TYPE

#LIB local
declare -i lib_platf_virtualized


#Import logger
source "$( cd "${BASH_SOURCE[0]%/*}" && pwd )/saphana-logger" || { echo 'unable to load saphana-logger library' >&2; exit 1; }

_lib_helper_main
